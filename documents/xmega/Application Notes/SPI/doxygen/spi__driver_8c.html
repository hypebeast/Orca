<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="2"><p><A href=http://www.atmel.com ><img src="atmel.jpg"/ border=0></A></p><br /></td>
    <td colspan="2"> <strong><font face="Helvetica" color="#000000" size="+3">Xmega Application Note</font></strong></td>
    <td colspan="2"><p><A href=http://www.atmel.com/products/AVR><img src="AVR_logo_blue.gif"/ border=0></A></p><br /></td>
  </tr>
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>
</table>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>spi_driver.c File Reference</h1>XMEGA SPI driver source file.  
<a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="spi__driver_8h_source.html">spi_driver.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for spi_driver.c:</div>
<div class="dynsection">
<p><center><img src="spi__driver_8c__incl.png" border="0" usemap="#spi_driver.c_map" alt=""></center>
<map name="spi_driver.c_map">
<area shape="rect" id="node3" href="spi__driver_8h.html" title="XMEGA SPI driver header file." alt="" coords="88,83,173,111"><area shape="rect" id="node5" href="avr__compiler_8h.html" title="This file implements some macros that makes the IAR C&#45;compiler and avr&#45;gcc work with..." alt="" coords="79,161,183,189"></map>
</div>

<p>
<a href="spi__driver_8c_source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#e7f66be10b2b5c1bf2d5140ebc20ecc2">SPI_MasterCreateDataPacket</a> (<a class="el" href="structSPI__DataPacket.html">SPI_DataPacket_t</a> *<a class="el" href="spi__polled__example_8c.html#1315dc698fa109813e537dc99162c05b">dataPacket</a>, const uint8_t *transmitData, uint8_t *receiveData, uint8_t bytesToTransceive, PORT_t *ssPort, uint8_t ssPinMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create data packet.  <a href="#e7f66be10b2b5c1bf2d5140ebc20ecc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#686959cbf2746510fc6243c00e68e375">SPI_MasterInit</a> (<a class="el" href="structSPI__Master.html">SPI_Master_t</a> *spi, SPI_t *module, PORT_t *port, bool lsbFirst, SPI_MODE_t mode, SPI_INTLVL_t intLevel, bool clk2x, SPI_PRESCALER_t clockDivision)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize SPI module as master.  <a href="#686959cbf2746510fc6243c00e68e375"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#cf59eb5c003c2641f8ff81f380c047dc">SPI_MasterInterruptHandler</a> (<a class="el" href="structSPI__Master.html">SPI_Master_t</a> *spi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common SPI master interrupt service routine.  <a href="#cf59eb5c003c2641f8ff81f380c047dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#ef12166f3f0e5074b9ec510591e62845">SPI_MasterInterruptTransceivePacket</a> (<a class="el" href="structSPI__Master.html">SPI_Master_t</a> *spi, <a class="el" href="structSPI__DataPacket.html">SPI_DataPacket_t</a> *<a class="el" href="spi__polled__example_8c.html#1315dc698fa109813e537dc99162c05b">dataPacket</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start transmission.  <a href="#ef12166f3f0e5074b9ec510591e62845"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#d76b05bcf9b884215797012fccc67cd9">SPI_MasterTransceiveByte</a> (<a class="el" href="structSPI__Master.html">SPI_Master_t</a> *spi, uint8_t TXdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SPI mastertransceive byte.  <a href="#d76b05bcf9b884215797012fccc67cd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#a284d2bee7d1548b5b064b36cfc43bee">SPI_MasterTransceivePacket</a> (<a class="el" href="structSPI__Master.html">SPI_Master_t</a> *spi, <a class="el" href="structSPI__DataPacket.html">SPI_DataPacket_t</a> *<a class="el" href="spi__polled__example_8c.html#1315dc698fa109813e537dc99162c05b">dataPacket</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SPI transceive data packet.  <a href="#a284d2bee7d1548b5b064b36cfc43bee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi__driver_8c.html#063ebd338e3bd8ab7dc088eb2a9b06fc">SPI_SlaveInit</a> (<a class="el" href="structSPI__Slave.html">SPI_Slave_t</a> *spi, SPI_t *module, PORT_t *port, bool lsbFirst, SPI_MODE_t mode, SPI_INTLVL_t intLevel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize SPI module as slave.  <a href="#063ebd338e3bd8ab7dc088eb2a9b06fc"></a><br></td></tr>
</table>
<hr><h2>Detailed Description</h2>
XMEGA SPI driver source file. 
<p>
This file contains the function implementations the XMEGA SPI driver.<p>
The driver is not intended for size and/or speed critical code, since most functions are just a few lines of code, and the function call overhead would decrease code performance. The driver is intended for rapid prototyping and documentation purposes for getting started with the XMEGA SPI module.<p>
For size and/or speed critical code, it is recommended to copy the function contents directly into your application instead of making a function call.<p>
Several functions use the following construct: "some_register = ... | (some_parameter ? SOME_BIT_bm : 0) | ..." Although the use of the ternary operator ( if ? then : else ) is discouraged, in some occasions the operator makes it possible to write pretty clean and neat code. In this driver, the construct is used to set or not set a configuration bit based on a boolean input parameter, such as the "some_parameter" in the example above.<p>
<dl class="user" compact><dt><b>Application note:</b></dt><dd>AVR1309: Using the XMEGA SPI</dd></dl>
<dl class="user" compact><dt><b>Documentation</b></dt><dd>For comprehensive code documentation, supported compilers, compiler settings and supported devices see readme.html</dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support email: <a href="mailto:avr@atmel.com">avr@atmel.com</a></dd></dl>
<dl class="rcs" compact><dt><b>Revision</b></dt><dd>764 </dd></dl>
<dl class="rcs" compact><dt><b>Date</b></dt><dd>2007-11-06 14:52:26 +0100 (ti, 06 nov 2007) </dd></dl>
<br>
<p>
Copyright (c) 2008, Atmel Corporation All rights reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
3. The name of ATMEL may not be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
<p>Definition in file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="e7f66be10b2b5c1bf2d5140ebc20ecc2"></a><!-- doxytag: member="spi_driver.c::SPI_MasterCreateDataPacket" ref="e7f66be10b2b5c1bf2d5140ebc20ecc2" args="(SPI_DataPacket_t *dataPacket, const uint8_t *transmitData, uint8_t *receiveData, uint8_t bytesToTransceive, PORT_t *ssPort, uint8_t ssPinMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_MasterCreateDataPacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__DataPacket.html">SPI_DataPacket_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dataPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>transmitData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>receiveData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>bytesToTransceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PORT_t *&nbsp;</td>
          <td class="paramname"> <em>ssPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>ssPinMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create data packet. 
<p>
This function prepares a data packet for transmission. Note that memory for dataPacket, transmitData and receiveData must be allocated outside this function.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The size of the receiveData and transmitData must be equal and bytesToTransceive should be set accordingly.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dataPacket</em>&nbsp;</td><td>Pointer to data packet used for this transmission. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transmitData</em>&nbsp;</td><td>Pointer to data to transmit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>receiveData</em>&nbsp;</td><td>Pointer to receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytesToTransceive</em>&nbsp;</td><td>The number of bytes to transmit/receive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssPort</em>&nbsp;</td><td>Pointer to I/O port where the SS pin used for this transmission is located. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssPinMask</em>&nbsp;</td><td>Pin mask selecting the SS pin in ssPort. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00173">173</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00085">SPI_DataPacket::bytesToTransceive</a>, <a class="el" href="spi__driver_8h_source.html#l00086">SPI_DataPacket::bytesTransceived</a>, <a class="el" href="spi__driver_8h_source.html#l00087">SPI_DataPacket::complete</a>, <a class="el" href="spi__driver_8h_source.html#l00084">SPI_DataPacket::receiveData</a>, <a class="el" href="spi__driver_8h_source.html#l00082">SPI_DataPacket::ssPinMask</a>, <a class="el" href="spi__driver_8h_source.html#l00081">SPI_DataPacket::ssPort</a>, and <a class="el" href="spi__driver_8h_source.html#l00083">SPI_DataPacket::transmitData</a>.</p>

<p>Referenced by <a class="el" href="spi__interrupt__example_8c_source.html#l00104">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00179"></a>00179 {
<a name="l00180"></a>00180         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a>            = ssPort;
<a name="l00181"></a>00181         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#d5bfd2fd9147c5630f081732ad5b460d" title="SS pin mask.">ssPinMask</a>         = ssPinMask;
<a name="l00182"></a>00182         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#5d5a43d312646214e06b4b96f51fda85" title="Pointer to data to transmit.">transmitData</a>      = transmitData;
<a name="l00183"></a>00183         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#909914bba4768e9c2bddfc47c15930a8" title="Pointer to where to store received data.">receiveData</a>       = receiveData;
<a name="l00184"></a>00184         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#045a49ba2e0a6d2651af37541793edc0" title="Number of bytes to transfer.">bytesToTransceive</a>  = bytesToTransceive;
<a name="l00185"></a>00185         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#aea51f33b0cdffcdcfefab211f964cad" title="Number of bytes transfered.">bytesTransceived</a>   = 0;
<a name="l00186"></a>00186         dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#0264aba785d786f331d2f26dbc2175e2" title="Complete flag.">complete</a>          = <span class="keyword">false</span>;
<a name="l00187"></a>00187 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="686959cbf2746510fc6243c00e68e375"></a><!-- doxytag: member="spi_driver.c::SPI_MasterInit" ref="686959cbf2746510fc6243c00e68e375" args="(SPI_Master_t *spi, SPI_t *module, PORT_t *port, bool lsbFirst, SPI_MODE_t mode, SPI_INTLVL_t intLevel, bool clk2x, SPI_PRESCALER_t clockDivision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_MasterInit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__Master.html">SPI_Master_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_t *&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PORT_t *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lsbFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_MODE_t&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_INTLVL_t&nbsp;</td>
          <td class="paramname"> <em>intLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>clk2x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_PRESCALER_t&nbsp;</td>
          <td class="paramname"> <em>clockDivision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize SPI module as master. 
<p>
This function initializes a SPI module as master. The CTRL and INTCTRL registers for the SPI module is set according to the inputs to the function. In addition, data direction for the MOSI and SCK pins is set to output.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>The SPI_Master_t struct instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>module</em>&nbsp;</td><td>The SPI module. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The I/O port where the SPI module is connected. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lsbFirst</em>&nbsp;</td><td>Data order will be LSB first if this is set to a non-zero value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>SPI mode (Clock polarity and phase). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>intLevel</em>&nbsp;</td><td>SPI interrupt level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clk2x</em>&nbsp;</td><td>SPI double speed mode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clockDivision</em>&nbsp;</td><td>SPI clock prescaler divison factor. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00087">87</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00097">SPI_Master::dataPacket</a>, <a class="el" href="spi__driver_8h_source.html#l00096">SPI_Master::interrupted</a>, <a class="el" href="spi__driver_8h_source.html#l00094">SPI_Master::module</a>, <a class="el" href="spi__driver_8h_source.html#l00095">SPI_Master::port</a>, <a class="el" href="spi__driver_8h_source.html#l00067">SPI_MOSI_bm</a>, and <a class="el" href="spi__driver_8h_source.html#l00069">SPI_SCK_bm</a>.</p>

<p>Referenced by <a class="el" href="spi__interrupt__example_8c_source.html#l00104">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00095"></a>00095 {
<a name="l00096"></a>00096         spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>         = module;
<a name="l00097"></a>00097         spi-&gt;<a class="code" href="structSPI__Master.html#ca3cd07f9c5391a8271435b76ca682fd" title="Pointer to port.">port</a>           = port;
<a name="l00098"></a>00098         spi-&gt;<a class="code" href="structSPI__Master.html#f47c9a265937ac65dfc1c9872cf78580" title="True if interrupted by other master (SS pulled low).">interrupted</a>    = <span class="keyword">false</span>;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;CTRL   = clockDivision |                  <span class="comment">/* SPI prescaler. */</span>
<a name="l00101"></a>00101                               (clk2x ? SPI_CLK2X_bm : 0) |     <span class="comment">/* SPI Clock double. */</span>
<a name="l00102"></a>00102                               SPI_ENABLE_bm |                  <span class="comment">/* Enable SPI module. */</span>
<a name="l00103"></a>00103                               (lsbFirst ? SPI_DORD_bm  : 0) |  <span class="comment">/* Data order. */</span>
<a name="l00104"></a>00104                               SPI_MASTER_bm |                  <span class="comment">/* SPI master. */</span>
<a name="l00105"></a>00105                               mode;                            <span class="comment">/* SPI mode. */</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="comment">/* Interrupt level. */</span>
<a name="l00108"></a>00108         spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;INTCTRL = intLevel;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         <span class="comment">/* No assigned data packet. */</span>
<a name="l00111"></a>00111         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a> = NULL;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="comment">/* MOSI and SCK as output. */</span>
<a name="l00114"></a>00114         spi-&gt;<a class="code" href="structSPI__Master.html#ca3cd07f9c5391a8271435b76ca682fd" title="Pointer to port.">port</a>-&gt;DIRSET  = <a class="code" href="spi__driver_8h.html#b25ef8a84a7998540350cec9b02899b7" title="Bit mask for the MOSI pin.">SPI_MOSI_bm</a> | <a class="code" href="spi__driver_8h.html#e274fae9149815c25f6fa07406f16577" title="Bit mask for the SCK pin.">SPI_SCK_bm</a>;
<a name="l00115"></a>00115 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cf59eb5c003c2641f8ff81f380c047dc"></a><!-- doxytag: member="spi_driver.c::SPI_MasterInterruptHandler" ref="cf59eb5c003c2641f8ff81f380c047dc" args="(SPI_Master_t *spi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_MasterInterruptHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__Master.html">SPI_Master_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Common SPI master interrupt service routine. 
<p>
This function is called by the SPI interrupt service handlers. For each SPI module that uses this driver, the ISR should call this function with a pointer to the related SPI_Master_t struct as argument.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>Pointer to the modules own SPI_Master_t struct. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00199">199</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00085">SPI_DataPacket::bytesToTransceive</a>, <a class="el" href="spi__driver_8h_source.html#l00086">SPI_DataPacket::bytesTransceived</a>, <a class="el" href="spi__driver_8h_source.html#l00087">SPI_DataPacket::complete</a>, <a class="el" href="spi__interrupt__example_8c_source.html#l00065">dataPacket</a>, <a class="el" href="spi__driver_8h_source.html#l00097">SPI_Master::dataPacket</a>, <a class="el" href="spi__driver_8h_source.html#l00096">SPI_Master::interrupted</a>, <a class="el" href="spi__driver_8h_source.html#l00094">SPI_Master::module</a>, <a class="el" href="spi__driver_8h_source.html#l00084">SPI_DataPacket::receiveData</a>, <a class="el" href="spi__driver_8h_source.html#l00142">SPI_MasterSSHigh</a>, <a class="el" href="spi__driver_8h_source.html#l00082">SPI_DataPacket::ssPinMask</a>, <a class="el" href="spi__driver_8h_source.html#l00081">SPI_DataPacket::ssPort</a>, and <a class="el" href="spi__driver_8h_source.html#l00083">SPI_DataPacket::transmitData</a>.</p>

<p>Referenced by <a class="el" href="spi__interrupt__example_8c_source.html#l00175">ISR()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00200"></a>00200 {
<a name="l00201"></a>00201         uint8_t data;
<a name="l00202"></a>00202         uint8_t bytesTransceived = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#aea51f33b0cdffcdcfefab211f964cad" title="Number of bytes transfered.">bytesTransceived</a>;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <span class="comment">/* If SS pin interrupt (SS used and pulled low).</span>
<a name="l00205"></a>00205 <span class="comment">        *  No data received at this point. */</span>
<a name="l00206"></a>00206         <span class="keywordflow">if</span> ( !(spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;CTRL &amp; SPI_MASTER_bm) ) {
<a name="l00207"></a>00207                 spi-&gt;<a class="code" href="structSPI__Master.html#f47c9a265937ac65dfc1c9872cf78580" title="True if interrupted by other master (SS pulled low).">interrupted</a> = <span class="keyword">true</span>;
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="keywordflow">else</span> {  <span class="comment">/* Data interrupt. */</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212                 <span class="comment">/* Store received data. */</span>
<a name="l00213"></a>00213                 data = spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA;
<a name="l00214"></a>00214                 spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#909914bba4768e9c2bddfc47c15930a8" title="Pointer to where to store received data.">receiveData</a>[bytesTransceived] = data;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216                 <span class="comment">/* Next byte. */</span>
<a name="l00217"></a>00217                 bytesTransceived++;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219                 <span class="comment">/* If more data. */</span>
<a name="l00220"></a>00220                 <span class="keywordflow">if</span> (bytesTransceived &lt; spi-&gt;<a class="code" href="spi__interrupt__example_8c.html#1315dc698fa109813e537dc99162c05b" title="Data packet.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#045a49ba2e0a6d2651af37541793edc0" title="Number of bytes to transfer.">bytesToTransceive</a>) {
<a name="l00221"></a>00221                         <span class="comment">/* Put data byte in transmit data register. */</span>
<a name="l00222"></a>00222                         data = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#5d5a43d312646214e06b4b96f51fda85" title="Pointer to data to transmit.">transmitData</a>[bytesTransceived];
<a name="l00223"></a>00223                         spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA = data;
<a name="l00224"></a>00224                 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226                 <span class="comment">/* Transmission complete. */</span>
<a name="l00227"></a>00227                 <span class="keywordflow">else</span> {
<a name="l00228"></a>00228 
<a name="l00229"></a>00229                         <span class="comment">/* Release SS to slave(s). */</span>
<a name="l00230"></a>00230                         uint8_t ssPinMask = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#d5bfd2fd9147c5630f081732ad5b460d" title="SS pin mask.">ssPinMask</a>;
<a name="l00231"></a>00231                         <a class="code" href="spi__driver_8h.html#5a1c812b4333202c71204f6063007b88" title="Releases SPI SS line(s).">SPI_MasterSSHigh</a>(spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a>, ssPinMask);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233                         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#0264aba785d786f331d2f26dbc2175e2" title="Complete flag.">complete</a> = <span class="keyword">true</span>;
<a name="l00234"></a>00234                 }
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236         <span class="comment">/* Write back bytesTransceived to data packet. */</span>
<a name="l00237"></a>00237         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#aea51f33b0cdffcdcfefab211f964cad" title="Number of bytes transfered.">bytesTransceived</a> = bytesTransceived;
<a name="l00238"></a>00238 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ef12166f3f0e5074b9ec510591e62845"></a><!-- doxytag: member="spi_driver.c::SPI_MasterInterruptTransceivePacket" ref="ef12166f3f0e5074b9ec510591e62845" args="(SPI_Master_t *spi, SPI_DataPacket_t *dataPacket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_MasterInterruptTransceivePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__Master.html">SPI_Master_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPI__DataPacket.html">SPI_DataPacket_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dataPacket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start transmission. 
<p>
This function starts a SPI transmission. A data packet must be prepared for transmission first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>The SPI_Master_t struct instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataPacket</em>&nbsp;</td><td>The SPI_dataPacket_t struct instance.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status code </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SPI_OK</em>&nbsp;</td><td>The transmission was completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SPI_BUSY</em>&nbsp;</td><td>The SPI module is busy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SPI_INTERRUPTED</em>&nbsp;</td><td>The transmission was interrupted by another master. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00255">255</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00086">SPI_DataPacket::bytesTransceived</a>, <a class="el" href="spi__driver_8h_source.html#l00087">SPI_DataPacket::complete</a>, <a class="el" href="spi__driver_8h_source.html#l00097">SPI_Master::dataPacket</a>, <a class="el" href="spi__driver_8h_source.html#l00096">SPI_Master::interrupted</a>, <a class="el" href="spi__driver_8h_source.html#l00094">SPI_Master::module</a>, <a class="el" href="spi__driver_8h_source.html#l00095">SPI_Master::port</a>, <a class="el" href="spi__driver_8h_source.html#l00075">SPI_BUSY</a>, <a class="el" href="spi__driver_8h_source.html#l00074">SPI_INTERRUPTED</a>, <a class="el" href="spi__driver_8h_source.html#l00131">SPI_MasterSSLow</a>, <a class="el" href="spi__driver_8h_source.html#l00073">SPI_OK</a>, <a class="el" href="spi__driver_8h_source.html#l00066">SPI_SS_bm</a>, <a class="el" href="spi__driver_8h_source.html#l00082">SPI_DataPacket::ssPinMask</a>, <a class="el" href="spi__driver_8h_source.html#l00081">SPI_DataPacket::ssPort</a>, and <a class="el" href="spi__driver_8h_source.html#l00083">SPI_DataPacket::transmitData</a>.</p>

<p>Referenced by <a class="el" href="spi__interrupt__example_8c_source.html#l00104">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00257"></a>00257 {
<a name="l00258"></a>00258         uint8_t data;
<a name="l00259"></a>00259         <span class="keywordtype">bool</span> interrupted = spi-&gt;<a class="code" href="structSPI__Master.html#f47c9a265937ac65dfc1c9872cf78580" title="True if interrupted by other master (SS pulled low).">interrupted</a>;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         <span class="comment">/* If no packets sent so far. */</span>
<a name="l00262"></a>00262         <span class="keywordflow">if</span> (spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a> == NULL) {
<a name="l00263"></a>00263                 spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a> = dataPacket;
<a name="l00264"></a>00264         }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         <span class="comment">/* If ongoing transmission. */</span>
<a name="l00267"></a>00267         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#0264aba785d786f331d2f26dbc2175e2" title="Complete flag.">complete</a> == <span class="keyword">false</span>) {
<a name="l00268"></a>00268                 <span class="keywordflow">return</span> (<a class="code" href="spi__driver_8h.html#d4e7ccbd897e6b2c6bd58dc6f54a6536" title="The SPI module is busy with another transmission.">SPI_BUSY</a>);
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="comment">/* If interrupted by other master. */</span>
<a name="l00272"></a>00272         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interrupted) {
<a name="l00273"></a>00273                 <span class="comment">/* If SS released. */</span>
<a name="l00274"></a>00274                 <span class="keywordflow">if</span> (spi-&gt;<a class="code" href="structSPI__Master.html#ca3cd07f9c5391a8271435b76ca682fd" title="Pointer to port.">port</a>-&gt;OUT &amp; <a class="code" href="spi__driver_8h.html#de426db19a5895b24c295556a3e77ec1" title="Bit mask for the SS pin.">SPI_SS_bm</a>) {
<a name="l00275"></a>00275                         <span class="comment">/* No longer interrupted. */</span>
<a name="l00276"></a>00276                         interrupted = <span class="keyword">false</span>;
<a name="l00277"></a>00277                 }
<a name="l00278"></a>00278                 <span class="keywordflow">else</span> {
<a name="l00279"></a>00279                         <span class="keywordflow">return</span> (<a class="code" href="spi__driver_8h.html#9401257f08b062ba98ce270c7f4f38cb" title="The transmission was interrupted by another master.">SPI_INTERRUPTED</a>);
<a name="l00280"></a>00280                 }
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <span class="comment">/* NOT interrupted by other master.</span>
<a name="l00284"></a>00284 <span class="comment">        * Start transmission. */</span>
<a name="l00285"></a>00285         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a> = dataPacket;
<a name="l00286"></a>00286         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#0264aba785d786f331d2f26dbc2175e2" title="Complete flag.">complete</a> = <span class="keyword">false</span>;
<a name="l00287"></a>00287         spi-&gt;<a class="code" href="structSPI__Master.html#f47c9a265937ac65dfc1c9872cf78580" title="True if interrupted by other master (SS pulled low).">interrupted</a> = <span class="keyword">false</span>;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="comment">/* SS to slave(s) low.*/</span>
<a name="l00290"></a>00290         uint8_t ssPinMask = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#d5bfd2fd9147c5630f081732ad5b460d" title="SS pin mask.">ssPinMask</a>;
<a name="l00291"></a>00291         <a class="code" href="spi__driver_8h.html#0c5dd5c3cb03ee283a96ebeaa01ce60b" title="Pulls SPI SS line(s) low in order to address the slave devices.">SPI_MasterSSLow</a>(spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a>, ssPinMask);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#aea51f33b0cdffcdcfefab211f964cad" title="Number of bytes transfered.">bytesTransceived</a> = 0;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295         <span class="comment">/* Start sending data. */</span>
<a name="l00296"></a>00296         data = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#5d5a43d312646214e06b4b96f51fda85" title="Pointer to data to transmit.">transmitData</a>[0];
<a name="l00297"></a>00297         spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA = data;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         <span class="comment">/* Successs */</span>
<a name="l00300"></a>00300         <span class="keywordflow">return</span> (<a class="code" href="spi__driver_8h.html#3e74b193ca2b44501637f409f165b54a" title="The transmission completed successfully.">SPI_OK</a>);
<a name="l00301"></a>00301 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d76b05bcf9b884215797012fccc67cd9"></a><!-- doxytag: member="spi_driver.c::SPI_MasterTransceiveByte" ref="d76b05bcf9b884215797012fccc67cd9" args="(SPI_Master_t *spi, uint8_t TXdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI_MasterTransceiveByte           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__Master.html">SPI_Master_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>TXdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SPI mastertransceive byte. 
<p>
This function clocks data in the DATA register to the slave, while data from the slave is clocked into the DATA register. The function does not check for ongoing access from other masters before initiating a transfer. For multimaster systems, checkers should be added to avoid bus contention.<p>
SS line(s) must be pulled low before calling this function and released when finished.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is blocking and will not finish unless a successful transfer has been completed. It is recommended to use the interrupt-driven driver for applications where blocking functionality is not wanted.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>The SPI_Master_t struct instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TXdata</em>&nbsp;</td><td>Data to transmit to slave.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Data received from slave. </dd></dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00324">324</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00094">SPI_Master::module</a>.</p>

<p>Referenced by <a class="el" href="spi__polled__example_8c_source.html#l00105">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00325"></a>00325 {
<a name="l00326"></a>00326         <span class="comment">/* Send pattern. */</span>
<a name="l00327"></a>00327         spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA = TXdata;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="comment">/* Wait for transmission complete. */</span>
<a name="l00330"></a>00330         <span class="keywordflow">while</span>(!(spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;STATUS &amp; SPI_IF_bm)) {
<a name="l00331"></a>00331 
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         <span class="comment">/* Read received data. */</span>
<a name="l00334"></a>00334         uint8_t result = spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         <span class="keywordflow">return</span>(result);
<a name="l00337"></a>00337 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a284d2bee7d1548b5b064b36cfc43bee"></a><!-- doxytag: member="spi_driver.c::SPI_MasterTransceivePacket" ref="a284d2bee7d1548b5b064b36cfc43bee" args="(SPI_Master_t *spi, SPI_DataPacket_t *dataPacket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SPI_MasterTransceivePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__Master.html">SPI_Master_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPI__DataPacket.html">SPI_DataPacket_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dataPacket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SPI transceive data packet. 
<p>
This function transceives a number of bytes contained in a data packet struct. The SS line is kept low until all bytes are transceived. The received bytes are stored in the data packet struct.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>The SPI_Master_t struct instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataPacket</em>&nbsp;</td><td>The SPI_dataPacket_t struct instance.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Wether the function was successfully completed </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>Failure </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00354">354</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00085">SPI_DataPacket::bytesToTransceive</a>, <a class="el" href="spi__driver_8h_source.html#l00086">SPI_DataPacket::bytesTransceived</a>, <a class="el" href="spi__driver_8h_source.html#l00087">SPI_DataPacket::complete</a>, <a class="el" href="spi__driver_8h_source.html#l00097">SPI_Master::dataPacket</a>, <a class="el" href="spi__driver_8h_source.html#l00094">SPI_Master::module</a>, <a class="el" href="spi__driver_8h_source.html#l00084">SPI_DataPacket::receiveData</a>, <a class="el" href="spi__driver_8h_source.html#l00142">SPI_MasterSSHigh</a>, <a class="el" href="spi__driver_8h_source.html#l00131">SPI_MasterSSLow</a>, <a class="el" href="spi__driver_8h_source.html#l00082">SPI_DataPacket::ssPinMask</a>, <a class="el" href="spi__driver_8h_source.html#l00081">SPI_DataPacket::ssPort</a>, and <a class="el" href="spi__driver_8h_source.html#l00083">SPI_DataPacket::transmitData</a>.</p>

<p>Referenced by <a class="el" href="spi__polled__example_8c_source.html#l00105">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00356"></a>00356 {
<a name="l00357"></a>00357         <span class="comment">/* Check if data packet has been created. */</span>
<a name="l00358"></a>00358         <span class="keywordflow">if</span>(dataPacket == NULL) {
<a name="l00359"></a>00359                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         <span class="comment">/* Assign datapacket to SPI module. */</span>
<a name="l00363"></a>00363         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a> = dataPacket;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         uint8_t ssPinMask = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#d5bfd2fd9147c5630f081732ad5b460d" title="SS pin mask.">ssPinMask</a>;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <span class="comment">/* If SS signal to slave(s). */</span>
<a name="l00368"></a>00368         <span class="keywordflow">if</span> (spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a> != NULL) {
<a name="l00369"></a>00369                 <span class="comment">/* SS to slave(s) low. */</span>
<a name="l00370"></a>00370                 <a class="code" href="spi__driver_8h.html#0c5dd5c3cb03ee283a96ebeaa01ce60b" title="Pulls SPI SS line(s) low in order to address the slave devices.">SPI_MasterSSLow</a>(spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a>, ssPinMask);
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         <span class="comment">/* Transceive bytes. */</span>
<a name="l00374"></a>00374         uint8_t bytesTransceived = 0;
<a name="l00375"></a>00375         uint8_t bytesToTransceive = dataPacket-&gt;<a class="code" href="structSPI__DataPacket.html#045a49ba2e0a6d2651af37541793edc0" title="Number of bytes to transfer.">bytesToTransceive</a>;
<a name="l00376"></a>00376         <span class="keywordflow">while</span> (bytesTransceived &lt; bytesToTransceive) {
<a name="l00377"></a>00377 
<a name="l00378"></a>00378                 <span class="comment">/* Send pattern. */</span>
<a name="l00379"></a>00379                 uint8_t data = spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#5d5a43d312646214e06b4b96f51fda85" title="Pointer to data to transmit.">transmitData</a>[bytesTransceived];
<a name="l00380"></a>00380                 spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA = data;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382                 <span class="comment">/* Wait for transmission complete. */</span>
<a name="l00383"></a>00383                 <span class="keywordflow">while</span>(!(spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;STATUS &amp; SPI_IF_bm)) {
<a name="l00384"></a>00384 
<a name="l00385"></a>00385                 }
<a name="l00386"></a>00386                 <span class="comment">/* Read received data. */</span>
<a name="l00387"></a>00387                 data = spi-&gt;<a class="code" href="structSPI__Master.html#f8b0b673c357f5c89ce23bd67addad07" title="Pointer to what module to use.">module</a>-&gt;DATA;
<a name="l00388"></a>00388                 spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#909914bba4768e9c2bddfc47c15930a8" title="Pointer to where to store received data.">receiveData</a>[bytesTransceived] = data;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390                 bytesTransceived++;
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         <span class="comment">/* If SS signal to slave(s). */</span>
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a> != NULL) {
<a name="l00395"></a>00395                 <span class="comment">/* Release SS to slave(s). */</span>
<a name="l00396"></a>00396                 <a class="code" href="spi__driver_8h.html#5a1c812b4333202c71204f6063007b88" title="Releases SPI SS line(s).">SPI_MasterSSHigh</a>(spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#4470ce7b729b61e3a8ab9e6d190527ed" title="Pointer to SS port.">ssPort</a>, ssPinMask);
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         <span class="comment">/* Set variables to indicate that transmission is complete. */</span>
<a name="l00400"></a>00400         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#aea51f33b0cdffcdcfefab211f964cad" title="Number of bytes transfered.">bytesTransceived</a> = bytesTransceived;
<a name="l00401"></a>00401         spi-&gt;<a class="code" href="structSPI__Master.html#1f76c201feb816b5090fdb6965dae31e" title="Holds transceive data.">dataPacket</a>-&gt;<a class="code" href="structSPI__DataPacket.html#0264aba785d786f331d2f26dbc2175e2" title="Complete flag.">complete</a> = <span class="keyword">true</span>;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <span class="comment">/* Report success. */</span>
<a name="l00404"></a>00404         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00405"></a>00405 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="063ebd338e3bd8ab7dc088eb2a9b06fc"></a><!-- doxytag: member="spi_driver.c::SPI_SlaveInit" ref="063ebd338e3bd8ab7dc088eb2a9b06fc" args="(SPI_Slave_t *spi, SPI_t *module, PORT_t *port, bool lsbFirst, SPI_MODE_t mode, SPI_INTLVL_t intLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_SlaveInit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPI__Slave.html">SPI_Slave_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_t *&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PORT_t *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lsbFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_MODE_t&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_INTLVL_t&nbsp;</td>
          <td class="paramname"> <em>intLevel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize SPI module as slave. 
<p>
This function initializes a SPI module as slave. The CTRL and INTCTRL registers for the SPI module is set according to the inputs to the function. In addition, data direction for the MISO pin is set to output.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>The SPI_Slave_t instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>module</em>&nbsp;</td><td>Pointer to the SPI module. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The I/O port where the SPI module is connected. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lsbFirst</em>&nbsp;</td><td>Data order will be LSB first if this is set to true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>SPI mode (Clock polarity and phase). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>intLevel</em>&nbsp;</td><td>SPI interrupt level. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="spi__driver_8c_source.html#l00132">132</a> of file <a class="el" href="spi__driver_8c_source.html">spi_driver.c</a>.</p>

<p>References <a class="el" href="spi__driver_8h_source.html#l00104">SPI_Slave::module</a>, <a class="el" href="spi__driver_8h_source.html#l00105">SPI_Slave::port</a>, and <a class="el" href="spi__driver_8h_source.html#l00068">SPI_MISO_bm</a>.</p>

<p>Referenced by <a class="el" href="spi__interrupt__example_8c_source.html#l00104">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00138"></a>00138 {
<a name="l00139"></a>00139         <span class="comment">/* SPI module. */</span>
<a name="l00140"></a>00140         spi-&gt;<a class="code" href="structSPI__Slave.html#a300d08298ae13de4abf0a8f91f92888" title="Pointer to what module to use.">module</a>       = module;
<a name="l00141"></a>00141         spi-&gt;<a class="code" href="structSPI__Slave.html#ca18ee92ebb9363fc76231479603ae10" title="Pointer to port.">port</a>         = port;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         spi-&gt;<a class="code" href="structSPI__Slave.html#a300d08298ae13de4abf0a8f91f92888" title="Pointer to what module to use.">module</a>-&gt;CTRL = SPI_ENABLE_bm |                <span class="comment">/* Enable SPI module. */</span>
<a name="l00144"></a>00144                             (lsbFirst ? SPI_DORD_bm : 0) | <span class="comment">/* Data order. */</span>
<a name="l00145"></a>00145                             mode;                          <span class="comment">/* SPI mode. */</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147         <span class="comment">/* Interrupt level. */</span>
<a name="l00148"></a>00148         spi-&gt;<a class="code" href="structSPI__Slave.html#a300d08298ae13de4abf0a8f91f92888" title="Pointer to what module to use.">module</a>-&gt;INTCTRL = intLevel;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150         <span class="comment">/* MISO as output. */</span>
<a name="l00151"></a>00151         spi-&gt;<a class="code" href="structSPI__Slave.html#ca18ee92ebb9363fc76231479603ae10" title="Pointer to port.">port</a>-&gt;DIRSET = <a class="code" href="spi__driver_8h.html#cff2c412a483beecb2543e25e31d9b1a" title="Bit mask for the MISO pin.">SPI_MISO_bm</a>;
<a name="l00152"></a>00152 }
</pre></div>
<p>

</div>
</div><p>
</div>
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>

  <tr>
    <td colspan="6">
    <address style="align: right;"><small>
Generated on Mon Nov 2 13:52:26 2009 for AVR1309 Using the XMEGA SPI by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.9</small></address>
    </td>
  </tr>

</table>
