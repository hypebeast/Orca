<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="2"><p><A href=http://www.atmel.com ><img src="atmel.jpg"/ border=0></A></p><br /></td>
    <td colspan="2"> <strong><font face="Helvetica" color="#000000" size="+3">Xmega Application Note</font></strong></td>
    <td colspan="2"><p><A href=http://www.atmel.com/products/AVR><img src="AVR_logo_blue.gif"/ border=0></A></p><br /></td>
  </tr>
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>
</table>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>dma_driver.c File Reference</h1>XMEGA DMA Controller driver source file.  
<a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="dma__driver_8h_source.html">dma_driver.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for dma_driver.c:</div>
<div class="dynsection">
<p><center><img src="dma__driver_8c__incl.png" border="0" usemap="#dma_driver.c_map" alt=""></center>
<map name="dma_driver.c_map">
<area shape="rect" id="node3" href="dma__driver_8h.html" title="XMEGA DMA Controller driver header file." alt="" coords="84,83,177,111"><area shape="rect" id="node5" href="avr__compiler_8h.html" title="This file implements some macros that makes the IAR C&#45;compiler and avr&#45;gcc work with..." alt="" coords="79,161,183,189"></map>
</div>

<p>
<a href="dma__driver_8c_source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#305705215bcea21071eb48ea3724dc7f">DMA_CH_IsOngoing</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function checks if the channel has on-going transfers not finished yet.  <a href="#305705215bcea21071eb48ea3724dc7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#6dba66f48fde0ba9c4251a011ba4483f">DMA_CH_IsPending</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function check if the channel has transfers pending.  <a href="#6dba66f48fde0ba9c4251a011ba4483f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#60e9142c7d83e66dedd66af3db4feeaa">DMA_ConfigDoubleBuffering</a> (DMA_DBUFMODE_t dbufMode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function configures the double buffering feature of the DMA.  <a href="#60e9142c7d83e66dedd66af3db4feeaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#872eb050bb8eb45c6758ebb1075115cd">DMA_DisableChannel</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function disables one DMA channel sub module.  <a href="#872eb050bb8eb45c6758ebb1075115cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#c6c1f738d57317c61c6a05f44707a87a">DMA_DisableSingleShot</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function disables single-shot transfer mode for a channel.  <a href="#c6c1f738d57317c61c6a05f44707a87a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#3f30990836753fe014b8acab8704172c">DMA_EnableChannel</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function enables one DMA channel sub module.  <a href="#3f30990836753fe014b8acab8704172c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#270b98d9c246ce1f69724cb80ba22c5e">DMA_EnableSingleShot</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function enables single-shot transfer mode for a channel.  <a href="#270b98d9c246ce1f69724cb80ba22c5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#a0e0496a89286b3500acda4f214535fc">DMA_IsOngoing</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function checks if any channel have on-going transfers are not finished yet.  <a href="#a0e0496a89286b3500acda4f214535fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#c4ab769686c8e511b57ce064b52d8937">DMA_IsPending</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function check if there are any transfers pending.  <a href="#c4ab769686c8e511b57ce064b52d8937"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#35a483de1c773d6cd958434372054b8b">DMA_Reset</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function forces a software reset of the DMA module.  <a href="#35a483de1c773d6cd958434372054b8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#2e0454f5c70367f5d2887d5824fafeb4">DMA_ResetChannel</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function forces a software reset of the DMA channel sub module.  <a href="#2e0454f5c70367f5d2887d5824fafeb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#2805ac1def38017dc9bda328da764b23">DMA_ReturnStatus_blocking</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function return the interrupt flag status of a channel.  <a href="#2805ac1def38017dc9bda328da764b23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#bdb49e6c3f2c798cd23dd42d45c8281d">DMA_ReturnStatus_non_blocking</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function return the interrupt flag status of a channel.  <a href="#bdb49e6c3f2c798cd23dd42d45c8281d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#2b6fd1bd7c95e1fa36786b468e722aa7">DMA_SetIntLevel</a> (volatile DMA_CH_t *channel, DMA_CH_TRNINTLVL_t transferInt, DMA_CH_ERRINTLVL_t errorInt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function configures the interrupt levels for one DMA channel.  <a href="#2b6fd1bd7c95e1fa36786b468e722aa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#67480b2bd1d733871a96118fb8235462">DMA_SetPriority</a> (DMA_PRIMODE_t priMode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function selects what priority scheme to use for the DMA channels.  <a href="#67480b2bd1d733871a96118fb8235462"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#6866bc7e113434014dfc7a2308d8752b">DMA_SetTriggerSource</a> (volatile DMA_CH_t *channel, uint8_t trigger)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the transfer trigger source for a channel.  <a href="#6866bc7e113434014dfc7a2308d8752b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#28ff4b28fd9895e28b123153052b0437">DMA_SetupBlock</a> (volatile DMA_CH_t *channel, const void *srcAddr, DMA_CH_SRCRELOAD_t srcReload, DMA_CH_SRCDIR_t srcDirection, void *destAddr, DMA_CH_DESTRELOAD_t destReload, DMA_CH_DESTDIR_t destDirection, uint16_t blockSize, DMA_CH_BURSTLEN_t burstMode, uint8_t repeatCount, bool useRepeat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function configures the necessary registers for a block transfer.  <a href="#28ff4b28fd9895e28b123153052b0437"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma__driver_8c.html#b3d1ea8bae209c7c7d4a9f46d636868c">DMA_StartTransfer</a> (volatile DMA_CH_t *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sends a manual transfer request to the channel.  <a href="#b3d1ea8bae209c7c7d4a9f46d636868c"></a><br></td></tr>
</table>
<hr><h2>Detailed Description</h2>
XMEGA DMA Controller driver source file. 
<p>
This file contains the function implementations for the XMEGA DMA driver.<p>
The driver is not intended for size and/or speed critical code, since most functions are just a few lines of code, and the function call overhead would decrease code performance. The driver is intended for rapid prototyping and documentation purposes for getting started with the XMEGA DMA module.<p>
For size and/or speed critical code, it is recommended to copy the function contents directly into your application instead of making a function call.<p>
<dl class="user" compact><dt><b>Application note:</b></dt><dd>AVR1304: Using the XMEGA DMA Controller</dd></dl>
<dl class="user" compact><dt><b>Documentation</b></dt><dd>For comprehensive code documentation, supported compilers, compiler settings and supported devices see readme.html</dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support email: <a href="mailto:avr@atmel.com">avr@atmel.com</a></dd></dl>
<dl class="rcs" compact><dt><b>Revision</b></dt><dd>2593 </dd></dl>
<dl class="rcs" compact><dt><b>Date</b></dt><dd>2009-07-17 15:22:29 +0200 (fr, 17 jul 2009) </dd></dl>
<br>
<p>
Copyright (c) 2008, Atmel Corporation All rights reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
3. The name of ATMEL may not be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
<p>Definition in file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="305705215bcea21071eb48ea3724dc7f"></a><!-- doxytag: member="dma_driver.c::DMA_CH_IsOngoing" ref="305705215bcea21071eb48ea3724dc7f" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMA_CH_IsOngoing           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if the channel has on-going transfers not finished yet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel to check.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if the selected channel have on-going transfers, zero otherwise. </dd></dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00119">119</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00120"></a>00120 {
<a name="l00121"></a>00121         uint8_t flagMask;
<a name="l00122"></a>00122         flagMask = channel-&gt;CTRLB &amp; DMA_CH_CHBUSY_bm;
<a name="l00123"></a>00123         <span class="keywordflow">return</span> flagMask;
<a name="l00124"></a>00124 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6dba66f48fde0ba9c4251a011ba4483f"></a><!-- doxytag: member="dma_driver.c::DMA_CH_IsPending" ref="6dba66f48fde0ba9c4251a011ba4483f" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMA_CH_IsPending           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function check if the channel has transfers pending. 
<p>
This function checks if the channel selected have transfers that are pending, which means that a transfer has been requested by a trigger source or by a manual request, but the channel haven't yet started its transfer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel to check.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if the selected channel have pending transfers, zero otherwise. </dd></dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00149">149</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00150"></a>00150 {
<a name="l00151"></a>00151         uint8_t flagMask;
<a name="l00152"></a>00152         flagMask = channel-&gt;CTRLB &amp; DMA_CH_CHPEND_bm;
<a name="l00153"></a>00153         <span class="keywordflow">return</span> flagMask;
<a name="l00154"></a>00154 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="60e9142c7d83e66dedd66af3db4feeaa"></a><!-- doxytag: member="dma_driver.c::DMA_ConfigDoubleBuffering" ref="60e9142c7d83e66dedd66af3db4feeaa" args="(DMA_DBUFMODE_t dbufMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_ConfigDoubleBuffering           </td>
          <td>(</td>
          <td class="paramtype">DMA_DBUFMODE_t&nbsp;</td>
          <td class="paramname"> <em>dbufMode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function configures the double buffering feature of the DMA. 
<p>
Channel pair 0/1 and/or channel pair 2/3 can be configured to operation in a chained mode. This means that once the first channel has completed its transfer, the second channel takes over automatically. It is important to setup the channel pair with equal block sizes, repeat modes etc.<p>
Do not change these settings after a transfer has started.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dbufMode</em>&nbsp;</td><td>Double buffering mode. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00088">88</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00089"></a>00089 {
<a name="l00090"></a>00090         DMA.CTRL = ( DMA.CTRL &amp; ~DMA_DBUFMODE_gm ) | dbufMode;
<a name="l00091"></a>00091 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="872eb050bb8eb45c6758ebb1075115cd"></a><!-- doxytag: member="dma_driver.c::DMA_DisableChannel" ref="872eb050bb8eb45c6758ebb1075115cd" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_DisableChannel           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables one DMA channel sub module. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>On-going transfers will be aborted and the error flag be set if a channel is disabled in the middle of a transfer.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to disable. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00242">242</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00243"></a>00243 {
<a name="l00244"></a>00244         channel-&gt;CTRLA &amp;= ~DMA_CH_ENABLE_bm;
<a name="l00245"></a>00245 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c6c1f738d57317c61c6a05f44707a87a"></a><!-- doxytag: member="dma_driver.c::DMA_DisableSingleShot" ref="c6c1f738d57317c61c6a05f44707a87a" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_DisableSingleShot           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables single-shot transfer mode for a channel. 
<p>
In single-shot mode, one transfer trigger (manual or from a trigger source) only causes one single data transfer (1, 2, 4, or 8 byte). When not in single-shot mode, one transfer trigger causes one entire block transfer.<p>
Do not change this setting after a transfer has started.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to configure. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00361">361</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00362"></a>00362 {
<a name="l00363"></a>00363         channel-&gt;CTRLA &amp;= ~DMA_CH_SINGLE_bm;
<a name="l00364"></a>00364 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3f30990836753fe014b8acab8704172c"></a><!-- doxytag: member="dma_driver.c::DMA_EnableChannel" ref="3f30990836753fe014b8acab8704172c" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_EnableChannel           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables one DMA channel sub module. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A DMA channel will be automatically disabled when a transfer is finished.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to enable. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00229">229</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>

<p>Referenced by <a class="el" href="dma__example_8c_source.html#l00088">BlockMemCopy()</a>, and <a class="el" href="dma__example_8c_source.html#l00128">MultiBlockMemCopy()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00230"></a>00230 {
<a name="l00231"></a>00231         channel-&gt;CTRLA |= DMA_CH_ENABLE_bm;
<a name="l00232"></a>00232 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="270b98d9c246ce1f69724cb80ba22c5e"></a><!-- doxytag: member="dma_driver.c::DMA_EnableSingleShot" ref="270b98d9c246ce1f69724cb80ba22c5e" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_EnableSingleShot           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables single-shot transfer mode for a channel. 
<p>
In single-shot mode, one transfer trigger (manual or from a trigger source) only causes one single data transfer (1, 2, 4, or 8 byte). When not in single-shot mode, one transfer trigger causes one entire block transfer. Do not change this setting after a transfer has started.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to configure. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00345">345</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00346"></a>00346 {
<a name="l00347"></a>00347         channel-&gt;CTRLA |= DMA_CH_SINGLE_bm;
<a name="l00348"></a>00348 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a0e0496a89286b3500acda4f214535fc"></a><!-- doxytag: member="dma_driver.c::DMA_IsOngoing" ref="a0e0496a89286b3500acda4f214535fc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMA_IsOngoing           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if any channel have on-going transfers are not finished yet. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if any channel have on-going transfers, zero otherwise. </dd></dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00131">131</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00132"></a>00132 {
<a name="l00133"></a>00133         uint8_t flagMask;
<a name="l00134"></a>00134         flagMask = DMA.STATUS &amp; 0xF0;
<a name="l00135"></a>00135         <span class="keywordflow">return</span> flagMask;
<a name="l00136"></a>00136 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c4ab769686c8e511b57ce064b52d8937"></a><!-- doxytag: member="dma_driver.c::DMA_IsPending" ref="c4ab769686c8e511b57ce064b52d8937" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMA_IsPending           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function check if there are any transfers pending. 
<p>
This function checks if any channel have transfers that are pending, which means that a transfer has been requested by a trigger source or by a manual request, but the channels haven't yet started its transfer.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if the selected channel have pending transfers, zero otherwise. </dd></dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00166">166</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00167"></a>00167 {
<a name="l00168"></a>00168         uint8_t flagMask;
<a name="l00169"></a>00169         flagMask = DMA.STATUS &amp; 0x0F;
<a name="l00170"></a>00170         <span class="keywordflow">return</span> flagMask;
<a name="l00171"></a>00171 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="35a483de1c773d6cd958434372054b8b"></a><!-- doxytag: member="dma_driver.c::DMA_Reset" ref="35a483de1c773d6cd958434372054b8b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_Reset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function forces a software reset of the DMA module. 
<p>
All registers will be set to their default values. If the DMA module is enabled, it must and will be disabled before being reset. It will not be enabled afterwards. 
<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00068">68</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00069"></a>00069 {                                   
<a name="l00070"></a>00070         DMA.CTRL &amp;= ~DMA_ENABLE_bm;
<a name="l00071"></a>00071         DMA.CTRL |= DMA_RESET_bm;   
<a name="l00072"></a>00072         <span class="keywordflow">while</span> (DMA.CTRL &amp; DMA_RESET_bm);        <span class="comment">// Wait until reset is completed</span>
<a name="l00073"></a>00073 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2e0454f5c70367f5d2887d5824fafeb4"></a><!-- doxytag: member="dma_driver.c::DMA_ResetChannel" ref="2e0454f5c70367f5d2887d5824fafeb4" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_ResetChannel           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function forces a software reset of the DMA channel sub module. 
<p>
All registers will be set to their default values. If the channel is enabled, it must and will be disabled before being reset. It will not be enabled afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to reset. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00256">256</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00257"></a>00257 {
<a name="l00258"></a>00258         channel-&gt;CTRLA &amp;= ~DMA_CH_ENABLE_bm;
<a name="l00259"></a>00259         channel-&gt;CTRLA |= DMA_CH_RESET_bm;
<a name="l00260"></a>00260         channel-&gt;CTRLA &amp;= ~DMA_CH_RESET_bm;
<a name="l00261"></a>00261 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2805ac1def38017dc9bda328da764b23"></a><!-- doxytag: member="dma_driver.c::DMA_ReturnStatus_blocking" ref="2805ac1def38017dc9bda328da764b23" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMA_ReturnStatus_blocking           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function return the interrupt flag status of a channel. 
<p>
This function return the status of the channel selected either finishes an on-going transfer or encounters an error and aborts the transfer.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Flags covered by the channel will be cleared when this function exits. However, it will return the flag status. This is a BLOCKING function, and will go into a dead-lock if the flags never get set.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to check.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Relevant interrupt flags. </dd></dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00207">207</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00208"></a>00208 {
<a name="l00209"></a>00209         uint8_t flagMask;
<a name="l00210"></a>00210         uint8_t relevantFlags;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         flagMask = DMA_CH_ERRIF_bm | DMA_CH_TRNIF_bm;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">do</span> {
<a name="l00215"></a>00215                 relevantFlags = channel-&gt;CTRLB &amp; flagMask;
<a name="l00216"></a>00216         } <span class="keywordflow">while</span> (relevantFlags == 0x00);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         channel-&gt;CTRLB = flagMask;
<a name="l00219"></a>00219         <span class="keywordflow">return</span> relevantFlags;
<a name="l00220"></a>00220 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bdb49e6c3f2c798cd23dd42d45c8281d"></a><!-- doxytag: member="dma_driver.c::DMA_ReturnStatus_non_blocking" ref="bdb49e6c3f2c798cd23dd42d45c8281d" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMA_ReturnStatus_non_blocking           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function return the interrupt flag status of a channel. 
<p>
This function return the status the channels selected finishes an on-going transfer or encounters an error and aborts the transfer.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Flags covered by the channel will NOT be cleared when this function exits.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to check.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Relevant interrupt flags. </dd></dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00185">185</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>

<p>Referenced by <a class="el" href="dma__example_8c_source.html#l00128">MultiBlockMemCopy()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00186"></a>00186 {
<a name="l00187"></a>00187         uint8_t relevantFlags;
<a name="l00188"></a>00188         relevantFlags = channel-&gt;CTRLB &amp; (DMA_CH_ERRIF_bm | DMA_CH_TRNIF_bm);
<a name="l00189"></a>00189         <span class="keywordflow">return</span> relevantFlags;
<a name="l00190"></a>00190 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2b6fd1bd7c95e1fa36786b468e722aa7"></a><!-- doxytag: member="dma_driver.c::DMA_SetIntLevel" ref="2b6fd1bd7c95e1fa36786b468e722aa7" args="(volatile DMA_CH_t *channel, DMA_CH_TRNINTLVL_t transferInt, DMA_CH_ERRINTLVL_t errorInt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_SetIntLevel           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_TRNINTLVL_t&nbsp;</td>
          <td class="paramname"> <em>transferInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_ERRINTLVL_t&nbsp;</td>
          <td class="paramname"> <em>errorInt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function configures the interrupt levels for one DMA channel. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The interrupt level parameter use the data type for channel 0, regardless of which channel is used. This is because we use the same function for all channel. This method relies upon channel bit fields to be located this way: CH3:CH2:CH1:CH0.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transferInt</em>&nbsp;</td><td>Transfer Complete Interrupt Level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorInt</em>&nbsp;</td><td>Transfer Error Interrupt Level. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00275">275</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>

<p>Referenced by <a class="el" href="dma__example_8c_source.html#l00172">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00278"></a>00278 {
<a name="l00279"></a>00279         channel-&gt;CTRLB = (channel-&gt;CTRLB &amp; ~(DMA_CH_ERRINTLVL_gm | DMA_CH_TRNINTLVL_gm)) |
<a name="l00280"></a>00280                          transferInt | errorInt;
<a name="l00281"></a>00281 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="67480b2bd1d733871a96118fb8235462"></a><!-- doxytag: member="dma_driver.c::DMA_SetPriority" ref="67480b2bd1d733871a96118fb8235462" args="(DMA_PRIMODE_t priMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_SetPriority           </td>
          <td>(</td>
          <td class="paramtype">DMA_PRIMODE_t&nbsp;</td>
          <td class="paramname"> <em>priMode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function selects what priority scheme to use for the DMA channels. 
<p>
It decides what channels to schedule in a round-robin manner, which means that they take turns in acquiring the data bus for individual data transfers. Channels not included in the round-robin scheme will have fixed priorities, with channel 0 having highest priority.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not change these settings after a transfer has started.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>priMode</em>&nbsp;</td><td>An enum selection the priority scheme to use. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00105">105</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00106"></a>00106 {
<a name="l00107"></a>00107         DMA.CTRL = ( DMA.CTRL &amp; ~DMA_PRIMODE_gm ) | priMode;
<a name="l00108"></a>00108 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6866bc7e113434014dfc7a2308d8752b"></a><!-- doxytag: member="dma_driver.c::DMA_SetTriggerSource" ref="6866bc7e113434014dfc7a2308d8752b" args="(volatile DMA_CH_t *channel, uint8_t trigger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_SetTriggerSource           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>trigger</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the transfer trigger source for a channel. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A manual transfer requests can be used even after setting a trigger source. Do not change this setting after a transfer has started.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigger</em>&nbsp;</td><td>The trigger source ID. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00375">375</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00376"></a>00376 {
<a name="l00377"></a>00377         channel-&gt;TRIGSRC = trigger;
<a name="l00378"></a>00378 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="28ff4b28fd9895e28b123153052b0437"></a><!-- doxytag: member="dma_driver.c::DMA_SetupBlock" ref="28ff4b28fd9895e28b123153052b0437" args="(volatile DMA_CH_t *channel, const void *srcAddr, DMA_CH_SRCRELOAD_t srcReload, DMA_CH_SRCDIR_t srcDirection, void *destAddr, DMA_CH_DESTRELOAD_t destReload, DMA_CH_DESTDIR_t destDirection, uint16_t blockSize, DMA_CH_BURSTLEN_t burstMode, uint8_t repeatCount, bool useRepeat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_SetupBlock           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_SRCRELOAD_t&nbsp;</td>
          <td class="paramname"> <em>srcReload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_SRCDIR_t&nbsp;</td>
          <td class="paramname"> <em>srcDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_DESTRELOAD_t&nbsp;</td>
          <td class="paramname"> <em>destReload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_DESTDIR_t&nbsp;</td>
          <td class="paramname"> <em>destDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CH_BURSTLEN_t&nbsp;</td>
          <td class="paramname"> <em>burstMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>repeatCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useRepeat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function configures the necessary registers for a block transfer. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The transfer must be manually triggered or a trigger source selected before the transfer starts. It is possible to reload the source and/or destination address after each data transfer, block transfer or only when the entire transfer is complete. Do not change these settings after a transfer has started.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcAddr</em>&nbsp;</td><td>Source memory address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcReload</em>&nbsp;</td><td>Source address reload mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcDirection</em>&nbsp;</td><td>Source address direction (fixed, increment, or decrement). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destAddr</em>&nbsp;</td><td>Destination memory address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destReload</em>&nbsp;</td><td>Destination address reload mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destDirection</em>&nbsp;</td><td>Destination address direction (fixed, increment, or decrement). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>Block size in number of bytes (0 = 64k). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>burstMode</em>&nbsp;</td><td>Number of bytes per data transfer (1, 2, 4, or 8 bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>repeatCount</em>&nbsp;</td><td>Number of blocks, 0x00 if you want to repeat at infinitum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useRepeat</em>&nbsp;</td><td>True if reapeat should be used, false if not. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00304">304</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>

<p>Referenced by <a class="el" href="dma__example_8c_source.html#l00088">BlockMemCopy()</a>, and <a class="el" href="dma__example_8c_source.html#l00128">MultiBlockMemCopy()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00315"></a>00315 {
<a name="l00316"></a>00316         channel-&gt;SRCADDR0 = (( (uint32_t) srcAddr) &gt;&gt; 0*8 ) &amp; 0xFF;
<a name="l00317"></a>00317         channel-&gt;SRCADDR1 = (( (uint32_t) srcAddr) &gt;&gt; 1*8 ) &amp; 0xFF;
<a name="l00318"></a>00318         channel-&gt;SRCADDR2 = (( (uint32_t) srcAddr) &gt;&gt; 2*8 ) &amp; 0xFF;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320         channel-&gt;DESTADDR0 = (( (uint32_t) destAddr) &gt;&gt; 0*8 ) &amp; 0xFF;
<a name="l00321"></a>00321         channel-&gt;DESTADDR1 = (( (uint32_t) destAddr) &gt;&gt; 1*8 ) &amp; 0xFF;
<a name="l00322"></a>00322         channel-&gt;DESTADDR2 = (( (uint32_t) destAddr) &gt;&gt; 2*8 ) &amp; 0xFF;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         channel-&gt;ADDRCTRL = (uint8_t) srcReload | srcDirection |
<a name="l00325"></a>00325                                       destReload | destDirection;
<a name="l00326"></a>00326         channel-&gt;TRFCNT = blockSize;
<a name="l00327"></a>00327         channel-&gt;CTRLA = ( channel-&gt;CTRLA &amp; ~( DMA_CH_BURSTLEN_gm | DMA_CH_REPEAT_bm ) ) |
<a name="l00328"></a>00328                           burstMode | ( useRepeat ? DMA_CH_REPEAT_bm : 0);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330         <span class="keywordflow">if</span> ( useRepeat ) {
<a name="l00331"></a>00331                 channel-&gt;REPCNT = repeatCount;
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b3d1ea8bae209c7c7d4a9f46d636868c"></a><!-- doxytag: member="dma_driver.c::DMA_StartTransfer" ref="b3d1ea8bae209c7c7d4a9f46d636868c" args="(volatile DMA_CH_t *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMA_StartTransfer           </td>
          <td>(</td>
          <td class="paramtype">volatile DMA_CH_t *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sends a manual transfer request to the channel. 
<p>
The bit will automatically clear when transfer starts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to request a transfer for. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dma__driver_8c_source.html#l00387">387</a> of file <a class="el" href="dma__driver_8c_source.html">dma_driver.c</a>.</p>

<p>Referenced by <a class="el" href="dma__example_8c_source.html#l00088">BlockMemCopy()</a>, and <a class="el" href="dma__example_8c_source.html#l00128">MultiBlockMemCopy()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00388"></a>00388 {
<a name="l00389"></a>00389         channel-&gt;CTRLA |= DMA_CH_TRFREQ_bm;
<a name="l00390"></a>00390 }
</pre></div>
<p>

</div>
</div><p>
</div>
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>

  <tr>
    <td colspan="6">
    <address style="align: right;"><small>
Generated on Fri Jul 17 17:12:43 2009 for AVR1304 Using the XMEGA DMA Controller by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.9</small></address>
    </td>
  </tr>

</table>
